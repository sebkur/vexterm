/* VexTerm - a lightweight and fast terminal emulator
 *
 * Copyright (C) 2010  Sebastian Kuerten
 *
 * This file is part of VexTerm.
 *
 * VexTerm is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * VexTerm is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with VexTerm.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <glib.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>

#include "menu.h"
#include "../helpers/tool.h"

G_DEFINE_TYPE (Menu, menu, GTK_TYPE_MENU_BAR);

static gboolean exit_cb(GtkWidget *widget);
static gboolean menubar_fullscreen_cb(GtkWidget *widget, gpointer menubar_p);

static gboolean window_event_cb(GtkWidget *window, GdkEventWindowState *event, gpointer menubar_p);
static void menu_map_cb(GtkWidget * widget, gpointer data);

GtkWidget * menu_new()
{
	Menu * menubar = g_object_new(VEX_TYPE_MENU, NULL);

	/********************************************************************************************
	* the following part is autogenerated; to regenerate, type:
	* :r !./misc/menu_gen.py 2 misc/Menu.txt
	********************************************************************************************/
	GtkWidget *item_1                      = gtk_menu_item_new_with_mnemonic("_File");
	GtkWidget *menu_1                      = gtk_menu_new();
	GtkWidget *item_1_1                    = gtk_menu_item_new_with_mnemonic("Open new _Window");
	GtkWidget *item_1_2                    = gtk_menu_item_new_with_mnemonic("Open new _Tab");
	GtkWidget *item_1_3                    = gtk_menu_item_new_with_mnemonic("_Quit");
	GtkWidget *item_2                      = gtk_menu_item_new_with_mnemonic("_View");
	GtkWidget *menu_2                      = gtk_menu_new();
	GtkWidget *item_2_1                    = gtk_check_menu_item_new_with_mnemonic("_Fullscreen");
	GtkWidget *item_2_2                    = gtk_menu_item_new_with_mnemonic("_Tabs Position");
	GtkWidget *item_3                      = gtk_menu_item_new_with_mnemonic("_Options");
	GtkWidget *menu_3                      = gtk_menu_new();
	GtkWidget *item_3_1                    = gtk_menu_item_new_with_mnemonic("_Preferences");
	GtkWidget *item_4                      = gtk_menu_item_new_with_mnemonic("_Profile");
	GtkWidget *item_5                      = gtk_menu_item_new_with_mnemonic("_Debug");
	GtkWidget *menu_5                      = gtk_menu_new();
	GtkWidget *item_5_1                    = gtk_check_menu_item_new_with_mnemonic("Show Scrolling _Region");
	GtkWidget *item_5_2                    = gtk_check_menu_item_new_with_mnemonic("Show _Status Bar");
	GtkWidget *item_6                      = gtk_menu_item_new_with_mnemonic("_Help");
	GtkWidget *menu_6                      = gtk_menu_new();
	GtkWidget *item_6_1                    = gtk_menu_item_new_with_mnemonic("_Manual");
	GtkWidget *item_6_2                    = gtk_menu_item_new_with_mnemonic("_About vexterm");
	GtkWidget *item_6_3                    = gtk_menu_item_new_with_mnemonic("_License");
	gtk_menu_item_set_submenu(GTK_MENU_ITEM(item_1),              menu_1);
	gtk_menu_item_set_submenu(GTK_MENU_ITEM(item_2),              menu_2);
	gtk_menu_item_set_submenu(GTK_MENU_ITEM(item_3),              menu_3);
	gtk_menu_item_set_submenu(GTK_MENU_ITEM(item_5),              menu_5);
	gtk_menu_item_set_submenu(GTK_MENU_ITEM(item_6),              menu_6);
	gtk_menu_shell_append(GTK_MENU_SHELL(menubar),            item_1);
	gtk_menu_shell_append(GTK_MENU_SHELL(menu_1),             item_1_1);
	gtk_menu_shell_append(GTK_MENU_SHELL(menu_1),             item_1_2);
	gtk_menu_shell_append(GTK_MENU_SHELL(menu_1),             item_1_3);
	gtk_menu_shell_append(GTK_MENU_SHELL(menubar),            item_2);
	gtk_menu_shell_append(GTK_MENU_SHELL(menu_2),             item_2_1);
	gtk_menu_shell_append(GTK_MENU_SHELL(menu_2),             item_2_2);
	gtk_menu_shell_append(GTK_MENU_SHELL(menubar),            item_3);
	gtk_menu_shell_append(GTK_MENU_SHELL(menu_3),             item_3_1);
	gtk_menu_shell_append(GTK_MENU_SHELL(menubar),            item_4);
	gtk_menu_shell_append(GTK_MENU_SHELL(menubar),            item_5);
	gtk_menu_shell_append(GTK_MENU_SHELL(menu_5),             item_5_1);
	gtk_menu_shell_append(GTK_MENU_SHELL(menu_5),             item_5_2);
	gtk_menu_shell_append(GTK_MENU_SHELL(menubar),            item_6);
	gtk_menu_shell_append(GTK_MENU_SHELL(menu_6),             item_6_1);
	gtk_menu_shell_append(GTK_MENU_SHELL(menu_6),             item_6_2);
	gtk_menu_shell_append(GTK_MENU_SHELL(menu_6),             item_6_3);
	menubar -> menu_file_new_window           = item_1_1;
	menubar -> menu_file_new_tab              = item_1_2;
	menubar -> menu_file_quit                 = item_1_3;
	menubar -> menu_view_fullscreen           = item_2_1;
	menubar -> menu_view_tabs_position        = item_2_2;
	menubar -> menu_options_preferences       = item_3_1;
	menubar -> menu_profiles                  = item_4;
	menubar -> menu_show_scrolling_region     = item_5_1;
	menubar -> menu_show_status_bar           = item_5_2;
	menubar -> menu_help_manual               = item_6_1;
	menubar -> menu_help_about_vexterm        = item_6_2;
	menubar -> menu_help_license              = item_6_3;
	// END
	/********************************************************************************************
	* end auto-generated part
	********************************************************************************************/

	menubar -> main_window = NULL;

	g_signal_connect( // this will assign 'menubar -> main_window' on map-signal
		G_OBJECT(menubar), "map",
		G_CALLBACK(menu_map_cb), NULL);

	/********************************************************************************************
	* signals 
	********************************************************************************************/
	g_signal_connect(
		G_OBJECT(menubar -> menu_file_quit), "activate",
		G_CALLBACK(exit_cb), (gpointer)menubar);
	g_signal_connect(
		G_OBJECT(menubar -> menu_view_fullscreen), "toggled", 
		G_CALLBACK(menubar_fullscreen_cb), (gpointer)menubar);

	return GTK_WIDGET(menubar);
}

static void menu_class_init(MenuClass *class)
{
        /*menu_signals[SIGNAL_NAME_n] = g_signal_new(
                "signal-name-n",
                G_OBJECT_CLASS_TYPE (class),
                G_SIGNAL_RUN_FIRST,
                G_STRUCT_OFFSET (MenuClass, function_name),
                NULL, NULL,
                g_cclosure_marshal_VOID__VOID,
                G_TYPE_NONE, 0);*/
}

static void menu_init(Menu *menu)
{
}

static gboolean exit_cb(GtkWidget *widget)
{
	exit(0);
}

static void menu_map_cb(GtkWidget * widget, gpointer data)
{
	Menu * menu = VEX_MENU(widget);
	GtkWidget * window = find_containing_gtk_window(widget);
	menu -> main_window = GTK_WINDOW(window);

	/* notice when window is being fullscreened */
	g_signal_connect(
		G_OBJECT(menu -> main_window), "window-state-event", 
		G_CALLBACK(window_event_cb), (gpointer)menu);
}


/****************************************************************************************************
* toggle fullscreen
****************************************************************************************************/
static gboolean menubar_fullscreen_cb(GtkWidget *widget, gpointer menubar_p)
{
	Menu * menubar = VEX_MENU(menubar_p);
	if (gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(menubar -> menu_view_fullscreen))){
		gdk_window_fullscreen(GTK_WIDGET(menubar -> main_window) -> window);
	}else{
		gdk_window_unfullscreen(GTK_WIDGET(menubar -> main_window) -> window);
	}
	return FALSE;
}

/****************************************************************************************************
* the events of the main window
* used to keep the "fullscreen"-checkbox up-to-date
****************************************************************************************************/
static gboolean window_event_cb(GtkWidget *window, GdkEventWindowState *event, gpointer menubar_p)
{
	Menu * menubar = VEX_MENU(menubar_p);
	if ((event -> changed_mask & GDK_WINDOW_STATE_FULLSCREEN) != 0){
		gboolean fullscreened = 
			(gdk_window_get_state(GTK_WIDGET(menubar -> main_window) -> window)
				& GDK_WINDOW_STATE_FULLSCREEN) != 0;
		gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menubar -> menu_view_fullscreen), fullscreened);
	}
	return FALSE;
}
